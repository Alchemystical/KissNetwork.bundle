#!/usr/bin/env python

"""Kiss(anime, cartoon, and drama) Service code"""

# import system modules
import base64

# import Shared Service Code
import test as Test

########################################################################################
def NormalizeURL(url):
    """
    This function should return a 'normalised' version of the given URL.
    Plex uses the URL
    """

    return url

########################################################################################
def MetadataObjectForURL(url):
    """
    This function should create and return a metadata object (for example, a
    VideoClipObject) and populate it with metadata from the given URL.
    Only the metadata should be added here, the object's key and rating_key properties
    will be synthesised based on the URL.
    """

    video_href = '/' + url.split('/', 3)[3]
    url = url.rsplit('/', 1)[0]

    Log.Info('MetadataObjectForURL url = %s' %url)

    # setup html for parsing
    html = HTML.ElementFromURL(url, headers=Test.GetHeadersForURL(url))

    show_name_raw = html.xpath('//div[@class="barContent"]/div/a[@class="bigChar"]/text()')[0]
    title_raw = html.xpath('//table[@class="listing"]/tr/td/a[@href="%s"]/../a/text()' %video_href)[0]
    title = title_raw.replace(show_name_raw, '').replace('\n', '').strip()

    Log.Debug('\nshow_name_raw | %s\ntitle_raw | %s\ntitle | %s' %(show_name_raw, title_raw, title))

    # set full summary
    summary = None
    match = None

    # enumerate array so we can find the Summary text
    for i, node in enumerate(html.xpath('//div[@id="container"]//p')):
        if node.xpath('./span[@class="info"][text()="Summary:"]'):
            match = int(i)
            break

    # add 1 to our Summary match to find the Summary text
    # wish the site was more consistant with its summary location... ugh
    for i, node in enumerate(html.xpath('//div[@id="container"]//p')):
        if match and match + 1 == i:
            # sometimes summary is inside a <span>
            if node.xpath('./span'):
                summary = node.xpath('./span')[0].text_content().strip()
                break
            else:
                summary = node.text_content().strip()
                break

    # some Summary text is not in the <p> but in it's own <div> or within a <table>
    summary_div = html.xpath('//div[@id="container"]//div[@class="barContent"]/div/div')
    summary_table = html.xpath('//div[@id="container"]//table//td')
    if not summary and summary_div:
        summary = summary_div[0].text_content().strip()
    elif not summary and summary_table:
        summary = summary_table[0].text_content().strip()

    if 'movie' in title.lower():
        return MovieObject(
            title=show_name_raw.strip(),
            summary=summary)
    elif 'episode' in title.lower():
        show_title = None
        ep_node = Regex('Episode (\d+)').search(title)
        episode_number = int(ep_node.group(1).lstrip('0'))
        episode_name = title.replace(ep_node.group(0), 'Episode %i' %episode_number)

        if "season" in show_name_raw.lower():

            test1 = Regex('(\d+)(?:[a-z][a-z]\ Season)').search(show_name_raw)
            if test1:
                season_number = int(test1.group(1))
            else:
                test2 = Regex('(?:Season\ )(\d+)').search(show_name_raw)
                if test2:
                    season_number = int(test2.group(1))
                else:
                    test3 = Regex('(First|Second|Third)\ (?:Season)').search(show_name_raw)
                    if test3:
                        test3_text = test3.group(1)
                        if test3_text == 'First':
                            season_number = int(1)
                        elif test3_text == 'Second':
                            season_number = int(2)
                        elif test3_text == 'Third':
                            season_number = int(3)
                    else:
                        season_number = None

            show_title_regex = Regex('^(.+?)(?:\ |\ (?:[1-9][a-z][a-z]|First|Second)\ )(?:Season|Episode)(.+|)').search(show_name_raw)
            show_title = show_title_regex.group(1) + show_title_regex.group(2)
            test = Regex('^(.+?)\ (?:\(Sub\)|\(Dub\))').search(show_title)

            if test:
                show_title = test.group(1)

            if season_number:
                new_title = 'Season %i | %s' %(season_number, episode_name)
            else:
                new_title = episode_name
        else:
            season_number = None
            test = Regex('^(.+?)\ (?:\(Sub\)|\(Dub\))').search(show_name_raw)
            if test:
                show_title = test.group(1)

            new_title = episode_name

        if not show_title:
            show_title = show_name_raw

        return EpisodeObject(
            title=new_title,
            show=show_title,
            season=season_number,
            index=episode_number,
            summary=summary)
    else:
        return VideoClipObject(title=title, summary=summary)

########################################################################################
def MediaObjectsForURL(url):
    """
    This function should create and return a list of media objects
    and part objects representing the media available at the given URL.
    Callbacks may be used if obtaining the final media location requires
    additional computation.
    """

    Log.Info('MediaObjectsForURL url = %s' %url)

    # setup html for parsing
    html = HTML.ElementFromURL(url, headers=Test.GetHeadersForURL(url))
    mo = []

    if "(Dub)" in html.xpath('//head/title/text()')[0]:
        Log.Info('language = English')
        AudioStreamObject.language_code = Locale.Language.English
    elif "(Sub)" in html.xpath('//head/title/text()')[0]:
        Log.Info('language = Japanese')
        AudioStreamObject.language_code = Locale.Language.Japanese
    else:
        Log.Info('No Language set')
        #AudioStreamObject.language_code = Locale.Language.English

    # create media objects for each video quality
    for node in html.xpath('//select[@id="selectQuality"]/option'):
        fmt = node.text
        video_url = node.get('value')

        mo.append(MediaObject(
            parts=[PartObject(key=Callback(PlayVideo, url=video_url))],
            video_resolution=fmt[:-1],
            container=Container.MP4,
            video_codec=VideoCodec.H264,
            audio_codec=AudioCodec.AAC,
            audio_channels=2,
            optimized_for_streaming = True))

    return mo

########################################################################################
@indirect
def PlayVideo(url, **kwargs):
    """Log the url and return the decoded base64 url"""

    path = base64.b64decode(url)

    Log.Info('PlayVideo url = %s' %path)

    return IndirectResponse(VideoClipObject, key=path)
