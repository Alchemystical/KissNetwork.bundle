#!/usr/bin/env python

"""Kiss(anime, cartoon, and drama) Service code"""

# import Shared Service Code
import headers as Headers
import common as Common
import metadata as Metadata
import subprefs as SubPrefs

########################################################################################
def MetadataObjectForURL(url):
    """
    This function should create and return a metadata object (for example, a
    VideoClipObject) and populate it with metadata from the given URL.
    Only the metadata should be added here, the object's key and rating_key properties
    will be synthesised based on the URL.
    """

    Log.Debug('*' * 80)
    Log.Debug('* MetadataObjectForURL url = %s' %url)

    video_id = int(url.split('=')[-1])
    show_url = url.rsplit('/', 1)[0]

    html = HTML.ElementFromURL(show_url, headers=Headers.GetHeadersForURL(show_url))
    Log.Debug('*' * 80)

    genres, genres_list = Metadata.GetGenres(html)
    date_added = Metadata.GetDateAdded(html, url)
    thumb, art = Metadata.get_thumb_and_art(html, url)

    # Setup MovieObject for Moives
    if 'Movie' in genres:
        Log.Debug('* This is a Movie')
        Log.Debug('*' * 80)

        # remove 'Movie' from genre list
        genre_list = [g for g in genres if not g == 'Movie']
        mi = Metadata.GetBaseMovieInfo(html, url)
        summary = Common.StringCode(string=mi['summary'], code='decode') if mi['summary'] else None

        return MovieObject(
            title=mi['title'],
            genres=genre_list,
            tags=Metadata.string_to_list(Common.StringCode(string=mi['tags'], code='decode')) if mi['tags'] else [],
            source_title=mi['source_title'],
            originally_available_at=date_added if date_added else None,
            year=int(mi['year']) if mi['year'] else None,
            countries=Metadata.string_to_list(Common.StringCode(string=mi['countries'], code='decode')) if mi['countries'] else [],
            thumb=thumb,
            art=art,
            summary=summary
            )
    # Setup EpisodeObject for all shows that are not Movies
    else:
        Log.Debug('* This is a TV Show')

        si = Metadata.GetBaseShowInfo(html, url)
        summary = Common.StringCode(string=si['summary'], code='decode') if si['summary'] else None
        tags = Metadata.string_to_list(Common.StringCode(string=si['tags'], code='decode')) if si['tags'] else []
        show_name_raw = html.xpath('//div[@class="barContent"]/div/a[@class="bigChar"]/text()')[0]
        start_title = Metadata.get_title(html, video_id, show_name_raw)
        season_number = Metadata.GetSeasonNumber(start_title, show_name_raw, tags, summary)
        ep_name, ep_number = Metadata.GetEpisodeNameAndNumber(html, start_title, url)
        new_title = Metadata.GetEpisodeTitle(int(season_number), ep_name, int(ep_number))

        return EpisodeObject(
            title=new_title,
            source_title=si['source_title'],
            show=si['tv_show_name'],
            season=int(season_number),
            index=int(ep_number),
            tags=tags,
            originally_available_at=date_added if date_added else None,
            thumb=thumb,
            art=art,
            summary=summary
            )

########################################################################################
def MediaObjectsForURL(url):
    """
    This function should create and return a list of media objects
    and part objects representing the media available at the given URL.
    Callbacks may be used if obtaining the final media location requires
    additional computation.
    """

    mo = []
    fmt_list = [('1080p', 'm37'), ('720p', 'm22'), ('360p', 'm18')]

    # create media objects for each video quality
    for fmt, m in fmt_list:
        mo.append(MediaObject(
            parts=[PartObject(key=Callback(PlayVideo, url=url, m=m))],
            video_resolution=fmt[:-1],
            container=Container.MP4,
            video_codec=VideoCodec.H264,
            audio_codec=AudioCodec.AAC,
            audio_channels=2,
            optimized_for_streaming=True
            ))

    return mo

########################################################################################
@indirect
def PlayVideo(url, m, **kwargs):
    """
    Get Video URL
    Currently available host: GoogleVideo, OneDrive, and OpenLoad
    GoogleVideo links have the potential for multiple resolutions links
    OneDrive & OpenLoad give only one link (the highest), so no optional resolutions
    """

    Log.Debug('*' * 80)
    Log.Debug('* Client.Product     = %s' %Client.Product)
    Log.Debug('* Client.Platform    = %s' %Client.Platform)
    Log.Debug('* Client.Version     = %s' %Client.Version)

    page_text = HTTP.Request(url, headers=Headers.GetHeadersForURL(url)).content
    onedrive = Regex('src\=\"(https\:\/\/onedrive\.live\.com\/prev\?.+?)\"').search(page_text)
    openload = Regex('src\=\"(https\:\/\/openload.+?)\"').search(page_text)
    if onedrive:
        Log.Debug('* OneDrive URL       = %s' %onedrive.group(1))
        vurl = get_onedrive_url(onedrive.group(1))
        Log.Debug('* PlayVideo URL      = %s' %vurl)
    elif openload:
        Log.Debug('* OpenLoad URL       = %s' %openload.group(1))
        vurl = get_openload_url(openload.group(1))
        Log.Debug('* PlayVideo URL      = %s' %vurl)
    else:
        vurl = get_googlevideo_url(page_text, url, m)
    Log.Debug('*' * 80)

    if not vurl:
        raise Ex.MediaNotAvailable
    else:
        return IndirectResponse(VideoClipObject, key=vurl)

####################################################################################################
def get_googlevideo_url(page_text, url, m):
    """
    Get GoogleVideo URLs
    Returns the Hights stream playable depending on the previous Stream Selections
    If Stream not found, then try's to find next hightest.
    Example:
    If 1080p not available then return 720p. If 720p not available then return 360p.
    """

    import base64

    html = HTML.ElementFromString(page_text)
    olist = html.xpath('//select[@id="selectQuality"]/option')
    type_title = Common.GetTypeTitle(url)
    if not olist:
        Log.Error('* This Video is broken, Kiss%s is working to fix it.' %type_title)
        raise Ex.MediaNotAvailable

    vurl = None
    vurls = []
    for node in olist:
        vurl_old = base64.b64decode(node.get('value'))
        try:
            vurls.append((vurl_old, int(vurl_old.split('=m')[1])))
        except:
            itag = Regex('itag\=(\d+)').search(vurl_old).group(1)
            vurls.append((vurl_old, int(itag)))

    for item, mm in sorted(vurls, key=lambda tup: tup[1]):
        vurl = item
        if 'm%s' %str(mm) == m:
            break

    Log.Debug('* PlayVideo URL      = %s' %vurl)

    prefs = SubPrefs.GetPrefs()
    if not 'samsung_fix' in prefs.keys():
        samsung_fix = 'false'
    else:
        samsung_fix = prefs['samsung_fix']
        if not samsung_fix:
            samsung_fix = 'false'

    if samsung_fix == 'true':
        Log.Debug('* Samsung Fix ON')
        Log.Debug('* Note: Videos will NO longer play outside the network connection.')
        try:
            vurl = get_redirect_url(path)
            Log.Debug('* URL Redirect       = %s' %vurl.split('?')[0] + '...')
        except:
            Log.Debug('* URL Redirect faild. Returning PlayVideo URL instead')

    return vurl

####################################################################################################
def get_redirect_url(rurl):
    """Expand Redirect URLs"""

    import urllib2

    opener = urllib2.build_opener(urllib2.HTTPRedirectHandler)
    try:
        request = opener.open(rurl, timeout=5)
        res = request.url
    except Exception as e:
        Log.Error('* URL Redirect Handler Error: Something went wrong, cannot access %s' %rurl)
        Log.Error('* URL Redirect Handler Error: %s' %str(e))
        res = False

    return res

####################################################################################################
def get_onedrive_url(onedrive_url):
    """
    Get OneDrive URLs
    Made by Twoure :P
    Code returns the download link for a OneDrive video
    Example Start URL
    https://onedrive.live.com/prev?cid=f90d37dd21022d17&id=F90D37DD21022D17%21108&authkey=%21AJZbMrbEbLJhvUk&parId=root&view=video&mode=interactiveEmbed
    Note the Start URL needs the 'cid', 'id', and 'authkey'
    No need to do the URL redirect, final video URL is NOT bound to local ip
    """

    html = HTML.ElementFromURL(onedrive_url)

    # Pull out the GetItemsLoaderConfing and store info in data dictionary
    for node in html.xpath('//script[@type="text/javascript"]'):
        match = Regex('(?s)GetItemsLoaderConfig\ \=\ (\{.*?\})\;').search(node.text_content())
        if match:
            test = match.group(1).replace('\n\r', '').strip()
            for i, s in enumerate(['cid', 'skyApiDomain', 'mkt', 'appId', 'canary', 'oauthToken', 'authKey', 'ticket', 'gb', 'rset']):
                if i == 0:
                    data = {s: Regex('%s\:\ \'(.*)\'\,' %s).search(test).group(1)}
                elif not s == 'rset':
                    data.update({s: Regex('%s\:\ \'(.*)\'\,' %s).search(test).group(1)})
                else:
                    data.update({s: Regex('%s\:\ \'(.*?)\'' %s).search(test).group(1)})
            break

    # parse parameters in URL
    uris = onedrive_url.split('&')
    for i, s in enumerate(uris):
        if i == 0:
            bs = s.split('?')[1]
            ss = bs.split('=')
            a = {ss[0]: ss[1]}
        else:
            ns = s.split('=')
            a.update({ns[0]: ns[1]})

    # create the request for the download url
    dl_url = 'https://onedrive.live.com/GetDownloadUrl/?cid=' + a['cid'] + '&resid=' + a['id'] + '&authkey=' + data['authKey'].decode('unicode-escape') + '&canary='
    # setup headers for request. Needs authKey and appId
    h = {'X-Requested-With': 'XMLHttpRequest', 'InvitationToken': data['authKey'].decode('unicode-escape'), 'AppId': data['appId'], 'Accept': 'application/json'}

    # open download request and parse json data
    try:
        # open download request and parse json data
        dl_data = JSON.ObjectFromURL(dl_url, headers=h)
        # remove the download info after .mp4, that way the video will play instead of force downloading
        vurl = dl_data['DownloadUrl'].split('?')[0]
    except Exception as e:
        Log.Error('* OneDrive Error: Cannot access %s' %dl_url)
        Log.Error('* OneDrive Error: %s' %str(e))
        vurl = False

    return vurl

####################################################################################################
def get_openload_url(openload_url):
    """
    Get OpenLoad URLs
    Code returns the download link for a OpenLoad video
    Example Start URL
    https://openload.co/embed/rano_HSH6Fk/%5BHorribleSubs%5D_GATE_-_21_%5B720p%5D-r976.mp4
    Note the Start URL needs the 'fid' after "/embed/"
    No need to do the URL redirect, final video URL is NOT bound to local ip
    """

    import aadecode as aa

    fid = openload_url.split('/')[4]
    base_url = openload_url.rsplit('/', 3)[0]
    # setup the url to ask for the Download Link
    ourl_req = base_url + '/getdllink/' + fid
    Log.Debug('* Get OpenLoad dlURL = %s' %ourl_req)

    try:
        s = HTTP.Request(ourl_req, encoding=('utf-8')).content
        # returns an aaencoded string, use aadecode to return JavaScript sting
        # then parse string for raw video URL
        aad = aa.AADecoder(s)
        jscode = aad.decode()
        url = Regex('\.attr\((.*)\)').search(jscode).group(1).split(',')[1].replace('\/', '/').lstrip('\'\"').rstrip('\'\"')
    except Exception as e:
        Log.Error('* OpenLoad Error: Something went wrong, cannot access %s' %ourl_req)
        Log.Error('* OpenLoad Error: %s' %str(e))
        url = False

    return url
