#!/usr/bin/env python

"""Kiss(anime, cartoon, and drama) Service code"""

# import system modules
import base64, urllib2

# import Shared Service Code
import headers as Headers
import common as Common
import subprefs as SubPrefs

########################################################################################
def NormalizeURL(url):
    """
    This function should return a 'normalised' version of the given URL.
    Plex uses the URL
    """

    return url

########################################################################################
def MetadataObjectForURL(url):
    """
    This function should create and return a metadata object (for example, a
    VideoClipObject) and populate it with metadata from the given URL.
    Only the metadata should be added here, the object's key and rating_key properties
    will be synthesised based on the URL.
    """

    video_href = '/' + url.split('/', 3)[3]
    video_id = video_href.split('=')[-1]
    Log.Debug('*' * 80)
    Log.Debug('* video href = %s' %video_href)
    Log.Debug('* video id   = %s' %video_id)
    url = url.rsplit('/', 1)[0]
    source_title = 'Kiss' + Common.GetBaseURL(url).split('kiss')[1].split('.')[0].title()

    Log.Debug('* MetadataObjectForURL url = %s' %url)
    Log.Debug('*' * 80)

    # setup html for parsing
    html = HTML.ElementFromURL(url, headers=Headers.GetHeadersForURL(url))
    Log.Debug('*' * 80)

    show_name_raw = html.xpath('//div[@class="barContent"]/div/a[@class="bigChar"]/text()')[0]
    title_raw = html.xpath('//table[@class="listing"]/tr/td/a[contains(@href, "%s")]/../a/text()' %video_id)[0]
    title = title_raw.replace(show_name_raw, '').replace('\n', '').strip()
    other_names = html.xpath('//p[span[@class="info"]="Other name:"]/a/text()')
    Log.Debug('* other names = %s' %other_names)
    genres = html.xpath('//p[span[@class="info"]="Genres:"]/a/text()')
    Log.Debug('* genres = %s' %genres)
    view_text = html.xpath('//p[span[@class="info"]="Status:"]')[0].text_content()[:100].replace(',', '')
    views = int(Regex('(?s).*(?:Views:).(\d+)').search(view_text).group(1))
    Log.Debug('* views = %i' %views)
    countries = html.xpath('//p[span[@class="info"]="Country:"]/a/text()')
    Log.Debug('* countries = %s' %countries)
    date_aired = html.xpath('//p[span[@class="info"]="Date aired:"]/text()')
    Log.Debug('* date aired = %s' %date_aired)
    Log.Debug('* show_name_raw = %s' %show_name_raw)
    Log.Debug('* title_raw = %s' %title_raw.strip())
    Log.Debug('* title = %s' %title)

    # setup thumb and art for video
    cover_url = Common.CorrectCoverImage(html.xpath('//head/link[@rel="image_src"]/@href')[0])
    if 'kiss' in cover_url:
        cover_file = cover_url.rsplit('/')[-1]
    elif 'http' in cover_url:
        cover_file = cover_url.split('/', 3)[3].replace('/', '_')
    else:
        Log.Error('*' * 80)
        Log.Error('* cover url not a valid picture url | %s' %cover_url)
        Log.Error('*' * 80)
        cover_file = None

    time_stamp = int(Datetime.TimestampFromDatetime(Datetime.Now()))

    if Common.CoverImageFileExist(cover_file):
        thumb = '/:/plugins/com.plexapp.plugins.kissnetwork/resources/%s?t=%s' %(cover_file, str(time_stamp))
    elif cover_url:
        thumb = cover_url
    else:
        thumb = None

    # Get art background
    art = '/:/plugins/com.plexapp.plugins.kissnetwork/resources/art-%s.jpg?t=%s' %(Common.GetTypeTitle(url).lower(), str(time_stamp))


    # set full summary
    summary = html.xpath('//p[span[@class="info"]="Summary:"]/following-sibling::p')
    # if summary found in <p> after <p><span>Summary:</span></p>
    if summary:
        Log.Debug('* summary in <p>')
        p_list = html.xpath('//div[@id="container"]//p')
        p_num = len(p_list)
        match = int(0)
        for i, node in enumerate(html.xpath('//div[@id="container"]//p')):
            if node.xpath('./span[@class="info"]="Summary:"'):
                match = int(i) + 1
                break

        new_p_list = p_list[match:p_num]
        sum_list = []
        for node in new_p_list:
            if node is not None:
                sum_text = node.text_content().strip()
                if sum_text:
                    sum_list.append(sum_text)

        if len(sum_list) > 1:
            Log.Debug('* summary was in %i <p>\'s' %int(len(sum_list)))
            summary = '\n\n'.join(sum_list).replace('Related Series', '').replace('Related:', '').strip().replace('\n\n\n', '\n')
        else:
            if len(sum_list) == 1:
                Log.Debug('* summary was in the only <p>')
                summary = sum_list[0]
            else:
                Log.Debug('* no summary found in <p>\'s, setting to \"None\"')
                summary = None
    else:
        summary = html.xpath('//p[span[@class="info"]="Summary:"]/following-sibling::p/span')
        # if summary found in <p><span> after <p><span>Summary:</span></p>
        if summary:
            Log.Debug('* summary is in <p><span>')
            summary = summary[0].text_content().strip()
        else:
            summary = html.xpath('//div[@id="container"]//div[@class="barContent"]/table//td')
            # if summary found in own <table>
            if summary:
                Log.Debug('* summary is in own <table>')
                summary = summary[0].text_content().strip()
            else:
                summary = html.xpath('//div[@id="container"]//div[@class="bigBarContainer"]/div[@class="barContent"]/div/div')
                # if summary found in own <div>
                if summary:
                    Log.Debug('* summary is in own <div>')
                    summary = summary[0].text_content().strip()
                else:
                    summary = html.xpath('//p[span[@class="info"]="Summary:"]')
                    # summary may be in <p><span>Summary:</span>summary</p>, ie text outside Summary span
                    if summary:
                        summary = summary[0].text_content().strip()
                        test = Regex('(?s)Summary\:.+?([\S].+)').search(summary)
                        if test:
                            Log.Debug('* summary is in <p><span>Summary:</span>summary</p>')
                            summary = test.group(1).strip()
                        else:
                            Log.Debug('* no summary found, setting summary to \"None\"')
                            summary = None
                    else:
                        # if no summary found then set to 'None'
                        Log.Debug('* no summary found, setting summary to \"None\"')
                        summary = None

    if summary:
        Log.Debug('* summary = %s' %summary)
        Log.Debug('*' * 80)

    # setup MovieObject
    if 'movie' in title.lower() or 'Movie' in genres and not 'episode' in title.lower():
        Log.Debug('* this is a movie')
        Log.Debug('*' * 80)

        # remove 'Movie' from genre list
        genre_list = [g for g in genres if not g == 'Movie']

        # try and set date and year
        if date_aired:
            try:
                date_aired = date_aired[1].strip()
                date = Datetime.ParseDate(date_aired)
                year = int(Datetime.ParseDate(date_aired).year)
            except:
                date = None
                year = None
        else:
            date = None
            year = None

        return MovieObject(
            title=show_name_raw.strip(),
            genres=genre_list,
            tags=other_names,
            source_title=source_title,
            originally_available_at=date,
            year=year,
            countries=countries,
            thumb=thumb,
            art=art,
            summary=summary)
    # setup EpisodeObject
    elif 'episode' in title.lower():
        Log.Debug('* this is a TV Show')

        show_title = None
        season_number = None
        # test title for episode # and season # via Regex
        ep_node = Regex('Episode(?:(?:\ (\d+)(\ .*))|(?:\ (\d+))|(\ .*))').search(title)
        se_node = Regex('Season (\d+)').search(title)

        # if season in title then set season number
        if se_node:
            season_number = int(se_node.group(1))

        # set up episode_name and episode number
        if ep_node:
            # if ep # and text found after # then:
            if ep_node.group(1) and ep_node.group(2):
                # set episode number (ep #)
                episode_number = int(ep_node.group(1))
                # if ep # != 0 then strip leading 0 from #
                if not episode_number == int(0):
                    episode_number = int(str(episode_number).lstrip('0'))
                # set episode name
                episode_name = 'E%i%s' %(episode_number, ' | ' + ep_node.group(2).lstrip(' -'))
            # if ep # with no text after it then:
            elif ep_node.group(3):
                episode_number = int(ep_node.group(3))
                if not episode_number == int(0):
                    episode_number = int(str(episode_number).lstrip('0'))

                episode_name = 'Episode %i' %episode_number
            # if ep found with no number but has text after it then:
            elif ep_node.group(4):
                # get episode list from show page
                test = html.xpath('//table[@class="listing"]/tr/td/a')
                # reverse list and enumerate to match selected video id with interation
                for i, item in enumerate(list(reversed(test))):
                    # get episode id
                    ep_id = int(item.get('href').split('=')[-1])
                    if int(video_id) == ep_id:
                        # add 1 to i since it starts at 0 in list
                        episode_number = int(i) + 1
                        episode_name = 'E%i%s' %(episode_number, ' | ' + ep_node.group(4).lstrip(' -'))
                        break
            # this shouldn't be needed but just in case the above fails
            else:
                episode_number = None
                episode_name = title
        # if Episode in name but Regex has not matches then add ep # and format ep name
        else:
            # get episode list from show page
            test = html.xpath('//table[@class="listing"]/tr/td/a')
            # reverse list and enumerate to match selected video id with interation
            for i, item in enumerate(list(reversed(test))):
                # get episode id
                ep_id = int(item.get('href').split('=')[-1])
                if int(video_id) == ep_id:
                    # add 1 to i since it starts at 0 in list
                    episode_number = int(i) + 1
                    episode_name = 'Episode %i' %episode_number
                    break

        # add genres to other_names, for 'tags' later
        for genre in genres:
            other_names.append(genre)

        # set up tags test lits of strings for finding season
        tags_test = [x.lower() for x in other_names]
        # setup summary for finding season
        if summary:
            summary_test = summary.lower()
        else:
            summary_test = 'none'

        # if season number was not found above and if 'season' in the show name
        # then try and find the season number in the show name
        if "season" in show_name_raw.lower() and not season_number:
            # test for "2nd Season" etc...
            test1 = Regex('(\d+)(?:[a-z][a-z]\ Season)').search(show_name_raw)
            if test1:
                season_number = int(test1.group(1))
            else:
                # test for "Season 2" etc...
                test2 = Regex('(?:Season\ )(\d+)').search(show_name_raw)
                if test2:
                    season_number = int(test2.group(1))
                else:
                    # test for "Second Season" etc...
                    test3 = Regex('(First|Second|Third)\ (?:Season)').search(show_name_raw)
                    if test3:
                        test3_text = test3.group(1)
                        if test3_text == 'First':
                            season_number = int(1)
                        elif test3_text == 'Second':
                            season_number = int(2)
                        elif test3_text == 'Third':
                            season_number = int(3)
                    # if season number not in show name then try and find it in the summary or tags test array
                    elif 'second season' in summary_test or FindPartElement(array=tags_test, string='second season'):
                        season_number = int(2)
                    elif 'third season' in summary_test or FindPartElement(array=tags_test, string='third season'):
                        season_number = int(3)
                    elif 'forth season' in summary_test or FindPartElement(array=tags_test, string='forth season'):
                        season_number = int(4)
                    #elif 'special' in summary_test or 'short' in summary_test or FindPartElement(array=tags_test, string='short') or FindPartElement(array=tags_test, string='special'):
                    elif FindPartElement(array=tags_test, string='short') or FindPartElement(array=tags_test, string='special'):
                        season_nubmer = int(0)
                    # if no season number found then set season to 1
                    else:
                        season_number = int(1)
        # if season number not above and if 'season' not in show name
        # try and find season number in summary or tags test string
        elif not season_number:
            if 'first season' in summary_test or FindPartElement(array=tags_test, string='first season'):
                season_number = int(1)
            elif 'second season' in summary_test or FindPartElement(array=tags_test, string='second season'):
                season_number = int(2)
            elif 'third season' in summary_test or FindPartElement(array=tags_test, string='third season'):
                season_number = int(3)
            elif 'forth season' in summary_test or FindPartElement(array=tags_test, string='forth season'):
                season_number = int(4)
            #elif 'special' in summary_test or 'short' in summary_test or FindPartElement(array=tags_test, string='short') or FindPartElement(array=tags_test, string='special'):
            elif FindPartElement(array=tags_test, string='short') or FindPartElement(array=tags_test, string='special'):
                season_number = int(0)
            # if no season number found then set season to 1
            else:
                season_number = int(1)

        # set show title
        show_title_regex = Regex('^(.+?)(?:\ |\ (?:[1-9][a-z][a-z]|First|Second)\ )(?:Season|Episode)(.+|)').search(show_name_raw)
        if show_title_regex:
            show_title = show_title_regex.group(1) + show_title_regex.group(2)
        else:
            show_title = show_name_raw

        # set episode title for EpisodeObject
        if season_number or season_number == 0:
            ep_test = Regex('E(?:\d+)(.*)').search(episode_name)
            # if no show name then return 'Season %i | Episode %i'
            if not ep_test:
                new_title = 'Season %i | %s' %(season_number, episode_name)
            # PHT displays season and episode already, so don't include in name
            elif Client.Platform == 'Plex Home Theater':
                new_title = ep_test.group(1).lstrip(' |')
            # shorten season and episode to include ep name
            else:
                new_title = 'S%i | E%i%s' %(season_number, episode_number, ep_test.group(1))
        # no season # found, so just return ep # and name
        else:
            new_title = episode_name

        # try and get the date and year
        if date_aired:
            try:
                date_aired = date_aired[1].lower().split('to')[0].split('-')[0].strip()
                Log.Debug('* date aired = %s' %date_aired)
                date = Datetime.ParseDate(date_aired)
                Log.Debug('* date = %s' %str(date))
            except:
                date = None
        else:
            date = None
        Log.Debug('*' * 80)

        return EpisodeObject(
            title=new_title,
            source_title=source_title,
            show=show_title,
            season=season_number,
            index=episode_number,
            tags=other_names,
            originally_available_at=date,
            thumb=thumb,
            art=art,
            summary=summary)
    # setup VideoClibObject in case video has no episode or movie data
    else:
        Log.Debug('* show not defined, so returned general video clip')
        Log.Debug('*' * 80)

        if date_aired:
            try:
                date_aired = date_aired[1].lower().split('to')[0].split('-')[0].strip()
                date = Datetime.ParseDate(date_aired)
                year = int(Datetime.ParseDate(date_aired).year)
            except:
                date = None
                year = None
        else:
            date = None
            year = None

        return VideoClipObject(
            title=title.lstrip('_'),
            genres=genres,
            tags=other_names,
            source_title=source_title,
            originally_available_at=date,
            year=year,
            countries=countries,
            thumb=thumb,
            art=art,
            summary=summary)

########################################################################################
def MediaObjectsForURL(url):
    """
    This function should create and return a list of media objects
    and part objects representing the media available at the given URL.
    Callbacks may be used if obtaining the final media location requires
    additional computation.
    """

    Log.Debug('* MediaObjectsForURL url = %s' %url)
    Log.Debug('*' * 80)

    # setup html for parsing
    html = HTML.ElementFromURL(url, headers=Headers.GetHeadersForURL(url))
    mo = []

    if "(Dub)" in html.xpath('//head/title/text()')[0]:
        Log.Debug('* language = English')
        AudioStreamObject.language_code = Locale.Language.English
    elif "(Sub)" in html.xpath('//head/title/text()')[0]:
        Log.Debug('* language = Japanese')
        AudioStreamObject.language_code = Locale.Language.Japanese
    else:
        Log.Debug('* No Language set. Setting to Unknown')
        AudioStreamObject.language_code = Locale.Language.Unknown

    Log.Debug('*' * 80)

    # create media objects for each video quality
    for node in html.xpath('//select[@id="selectQuality"]/option'):
        fmt = node.text
        video_url = node.get('value')

        mo.append(MediaObject(
            parts=[PartObject(key=Callback(PlayVideo, url=video_url))],
            video_resolution=fmt[:-1],
            container=Container.MP4,
            video_codec=VideoCodec.H264,
            audio_codec=AudioCodec.AAC,
            audio_channels=2,
            optimized_for_streaming=True))

    return mo

########################################################################################
@indirect
def PlayVideo(url, **kwargs):
    """Log the Client Product, Platform and base64 decoded PlayVideo URL"""

    path = base64.b64decode(url)
    vurl = path

    Log.Debug('*' * 80)
    Log.Debug('* Client.Product     = %s' %Client.Product)
    Log.Debug('* Client.Platform    = %s' %Client.Platform)
    Log.Debug('* PlayVideo URL      = %s' %path)

    for pref in SubPrefs.GetPrefs('com.plexapp.plugins.kissnetwork'):
        if (pref['id'] == 'samsung_fix') and (pref['value'] == 'true'):
            Log.Debug('* Samsung Fix ON')
            Log.Debug('* Note: Videos will NO longer play outside the network connection.')
            try:
                vurl = get_redirect_url(path)
                Log.Debug('* URL Redirect       = %s' %vurl.split('?')[0] + '...')
            except:
                Log.Debug('* URL Redirect faild. Returning PlayVideo URL instead')
            break

    Log.Debug('*' * 80)

    if not vurl:
        raise Ex.MediaNotAvailable

    return IndirectResponse(VideoClipObject, key=vurl)

########################################################################################
def FindPartElement(array=list, string=str):
    """fileter elements in array by sting, allows for loose matches"""

    if filter(lambda element: string in element, array):
        return True
    else:
        return False

####################################################################################################
def get_redirect_url(rurl):
    """Expand Redirect URLs"""

    opener = urllib2.build_opener(urllib2.HTTPRedirectHandler)
    request = opener.open(rurl)

    return request.url
